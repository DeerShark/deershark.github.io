<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星溢栈</title>
  
  <subtitle>看，有星划过天际</subtitle>
  <link href="https://blog.xez.cc/atom.xml" rel="self"/>
  
  <link href="https://blog.xez.cc/"/>
  <updated>2023-08-08T11:21:38.000Z</updated>
  <id>https://blog.xez.cc/</id>
  
  <author>
    <name>星溢栈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.pw/.me等多二字母后缀域名可备案啦</title>
    <link href="https://blog.xez.cc/posts/ab644aa9.html"/>
    <id>https://blog.xez.cc/posts/ab644aa9.html</id>
    <published>2023-08-08T17:28:58.000Z</published>
    <updated>2023-08-08T11:21:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虽然自己已经不需要再备案了，但是逛着逛着文档，看到目前还是有挺多<strong>二字母后缀</strong>域名可以备案了，这就意味着有更多<strong>比较短又有寓意</strong><del>（短小精悍）</del>的非主流（指非com,net）域名也能接入国内服务器了。</p></blockquote><p>自很早以前的一次对域名备案后缀的限制之后，很多域名因为后缀不在规定的可备案的域名后缀列表里面，一是<strong>不允许备案</strong>，二是国内域名平台都<strong>不允许进行注册</strong>了。</p><p>到如今开放了挺多二字母域名后缀的备案，同时国内域名平台这些域名后缀在开放注册的权限。但是相应的似乎注册和续费的费用也逐渐升高，但是对于广大想要一个好域名的<strong>Developer和Blogger来说</strong>无疑也一个很好的消息。（<psw>要不是国内服务器快，哪个博主愿意备案呢(￣▽￣)~</psw>）</p><p>这里整理了一份可备案的二字母域名后缀表格，除了包含后缀还有国内平台注册和续费最便宜的价格，截至时间为<strong>2023年8月8日</strong>：</p><div class="note info flat"><p>可备案的二字母域名后缀数据来自<a href="https://domain.miit.gov.cn/"><strong>工业和信息化部域名行业管理信息公示</strong></a>，价格信息来自<a href="https://www.nazhumi.com/"><strong>哪煮米</strong></a>。<br>其中<strong>西部数码国际</strong>与国内站点互通，所以也归类为国内平台。</p></div><table><thead><tr><th align="center">后缀</th><th align="center">最低注册价</th><th align="center">最低续费价</th><th align="center">最低转入价</th></tr></thead><tbody><tr><td align="center"><code>.pw</code></td><td align="center"><strong>10元</strong><br><a href="https://hk.west.cn/">西部数码国际</a></td><td align="center"><strong>29元</strong><br><a href="https://wanwang.aliyun.com/">阿里云</a></td><td align="center"><strong>68元</strong><br><a href="https://hk.west.cn/">西部数码国际</a></td></tr><tr><td align="center"><code>.me</code></td><td align="center"><strong>42元</strong><br><a href="https://www.west.cn/">西部数码</a></td><td align="center"><strong>106元</strong><br><a href="https://www.west.cn/">西部数码</a></td><td align="center"><strong>106元</strong><br><a href="https://hk.west.cn/">西部数码国际</a></td></tr><tr><td align="center"><code>.cc</code></td><td align="center"><strong>25元</strong><br><a href="https://www.west.cn/">西部数码</a></td><td align="center"><strong>39元</strong><br><a href="https://www.huaweicloud.com/">华为云</a></td><td align="center"><strong>39元</strong><br><a href="https://www.huaweicloud.com/">华为云</a></td></tr><tr><td align="center"><code>.tv</code></td><td align="center"><strong>189元</strong><br><a href="https://www.west.cn/">西部数码</a></td><td align="center"><strong>198元</strong><br><a href="https://www.west.cn/">西部数码</a></td><td align="center"><strong>190元</strong><br><a href="https://www.west.cn/">西部数码</a></td></tr><tr><td align="center"><code>.hk</code></td><td align="center"><strong>88元</strong><br><a href="https://hk.west.cn/">西部数码国际</a></td><td align="center"><strong>148元</strong><br><a href="https://hk.west.cn/">西部数码国际</a></td><td align="center"><strong>2元</strong><br><a href="https://hk.west.cn/">西部数码国际</a></td></tr><tr><td align="center"><code>.co</code></td><td align="center"><strong>60元</strong><br><a href="https://www.west.cn/">西部数码</a></td><td align="center"><strong>169元</strong><br><a href="https://www.west.cn/">西部数码</a></td><td align="center"><strong>169元</strong><br><a href="https://www.west.cn/">西部数码</a></td></tr></tbody></table><p>当然也有国际平台的统计表格：</p><div class="note info flat"><p>价格信息同样来自<a href="https://www.nazhumi.com/"><strong>哪煮米</strong></a>，价格为<code>-</code>的表示与上表相同。<br>汇率截至时间为<strong>2023年8月8日</strong>。</p></div><table><thead><tr><th align="center">后缀</th><th align="center">最低注册价</th><th align="center">最低续费价</th><th align="center">最低转入价</th></tr></thead><tbody><tr><td align="center"><code>.pw</code></td><td align="center"><strong>0.99美元(约7.14元)</strong><br><a href="https://alibabacloud.com/">AlibabaCloud</a></td><td align="center">-</td><td align="center"><strong>0美元</strong><br><a href="https://hexonet.net/">HEXONET</a></td></tr><tr><td align="center"><code>.me</code></td><td align="center"><strong>1706奈拉(约15.65元)</strong><br><a href="https://www.west.cn/">TFhost</a></td><td align="center"><strong>125里拉(约33.37元)</strong><br><a href="https://domains.google/intl/tr_tr/">Google Domains TR</a></td><td align="center"><strong>125里拉(约33.37元)</strong><br><a href="https://domains.google/intl/tr_tr/">Google Domains TR</a></td></tr><tr><td align="center"><code>.cc</code></td><td align="center">-</td><td align="center"><strong>125里拉(约33.37元)</strong><br><a href="https://domains.google/intl/tr_tr/">Google Domains TR</a></td><td align="center"><strong>125里拉(约33.37元)</strong><br><a href="https://domains.google/intl/tr_tr/">Google Domains TR</a></td></tr><tr><td align="center"><code>.tv</code></td><td align="center"><strong>9.99美元(约72.07元)</strong><br><a href="https://www.dreamhost.com/">DreamHost</a></td><td align="center"><strong>24.98美元(约180.20元)</strong><br><a href="https://www.spaceship.com/">Spaceship</a></td><td align="center"><strong>24.98美元(约180.20元)</strong><br><a href="https://www.spaceship.com/">Spaceship</a></td></tr><tr><td align="center"><code>.hk</code></td><td align="center">-</td><td align="center">-</td><td align="center"><strong>0美元</strong><br><a href="https://gandi.net/">gandi.net</a></td></tr><tr><td align="center"><code>.co</code></td><td align="center"><strong>185里拉(约49.38元)</strong><br><a href="https://domains.google/intl/tr_tr/">Google Domains TR</a></td><td align="center"><strong>185里拉(约49.38元)</strong><br><a href="https://domains.google/intl/tr_tr/">Google Domains TR</a></td><td align="center"><strong>185里拉(约49.38元)</strong><br><a href="https://domains.google/intl/tr_tr/">Google Domains TR</a></td></tr></tbody></table><p>国外一些平台其实挺实惠，可以先到平台注册域名过后，<strong>等待60天再转入国内域名平台备案</strong>（在国外平台的域名没有实名备案不了~），当然这里大多数平台都需要国外信用卡，没有的话也就享受不了了…</p><div class="note warning flat"><p>文章最后打个广告，博主也有一些闲置域名出售：<a href="/sell-domains/"><strong>域名小卖铺</strong></a>，域名品相好，价格还实惠ψ(｀∇´)ψ~</p></div><ul><li>更多可备案域名后缀可见：<a href="https://domain.miit.gov.cn/">工业和信息化部域名行业管理信息公示</a></li></ul><p><img src="/img/ab644aa9/2023-08-08-18-39-54.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;虽然自己已经不需要再备案了，但是逛着逛着文档，看到目前还是有挺多&lt;strong&gt;二字母后缀&lt;/strong&gt;域名可以备案了，这就意味着有更多&lt;strong&gt;比较短又有寓意&lt;/strong&gt;&lt;del&gt;（短小精悍）&lt;/del&gt;的非主流（指非com,ne</summary>
      
    
    
    
    <category term="消息快报" scheme="https://blog.xez.cc/categories/%E6%B6%88%E6%81%AF%E5%BF%AB%E6%8A%A5/"/>
    
    
    <category term="域名" scheme="https://blog.xez.cc/tags/%E5%9F%9F%E5%90%8D/"/>
    
    <category term="域名备案" scheme="https://blog.xez.cc/tags/%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88/"/>
    
    <category term=".pw域名" scheme="https://blog.xez.cc/tags/pw%E5%9F%9F%E5%90%8D/"/>
    
    <category term=".me域名" scheme="https://blog.xez.cc/tags/me%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>不使用EventSource的POST请求的SSE（Server-Sent Events）</title>
    <link href="https://blog.xez.cc/posts/5c051ec6.html"/>
    <id>https://blog.xez.cc/posts/5c051ec6.html</id>
    <published>2023-07-29T21:32:00.000Z</published>
    <updated>2023-08-08T10:35:46.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>最近在写一个类似于<code>ChatGPT</code>的流式输出的后端接口，查找资料以及控制台查看到这一类的开发都是使用的<code>SSE</code>。后端查资料一顿开搞，前端却犯了难…前端使用<code>EventSource</code>这个对象在MDN中的定义是只允许发送<code>GET</code>请求，而且还不能携带头部信息…后面查找资料发现可以这样使用，故翻译收藏起来了。</p></div><p>本文将解释如何使用 HTTP POST 请求从前端接收 <code>SSE</code>，<code>EventSource</code> 不支持该请求。大多数文章和文档都会告诉您需要 <code>GET</code> 请求才能接收事件，但事实并非如此。大多数 HTTP 库都会隐藏用于从 axios 等服务器接收响应的较低级别步骤。我们需要一个库，允许我们根据收到的每个网络请求（又称每个 SSE 消息）构建自己的响应。</p><h2 id="What-is-SSE"><a href="#What-is-SSE" class="headerlink" title="What is SSE?"></a>What is SSE?</h2><p>SSE（Server-Sent Events）是一种基于 HTTP 协议的服务器推送技术，它允许服务器实时向客户端推送数据，而无需客户端定时轮询或发送请求。SSE 的主要特点包括：</p><ul><li>单向通信：SSE 是从服务器向客户端的单向通信，客户端不需要发送任何请求就可以接收到服务器的推送数据。</li><li>实时性：SSE 的推送数据是实时的，客户端可以立即收到最新的数据。</li><li>可靠性：SSE 是基于 HTTP 协议的，因此可以使用 HTTP 的可靠性机制，例如重试、重连和错误处理。</li></ul><p>在 ChatGPT 的 AI 生成内容中，SSE 技术可以用来实时向客户端推送新生成的对话内容。当用户发起对话后，ChatGPT 会不断地生成新的对话内容，并通过 SSE 技术将新的内容实时地推送给客户端，从而实现实时对话的效果。</p><p>使用 SSE 技术的好处是能够节省客户端的网络带宽和服务器的资源，因为客户端不需要定时发送请求，而是等待服务器推送数据。此外，SSE 还具有实时性和可靠性的优势，可以保证客户端能够实时接收到最新的数据，而且在网络故障或其他错误时能够自动重试和重连。</p><p><img src="/img/5c051ec6/2023-07-29-21-45-54.png" alt="SSE 通信图"></p><h2 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works?"></a>How it works?</h2><ol><li>首先，我们将使用 <code>fetch</code> 向 <code>SSE</code> 端点发出 <code>POST</code> 请求。该端点将设置为返回多条带有响应标头 <code>ContentType: text/event-stream</code> 的消息。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/sse&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/event-stream&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: &#123;</span><br><span class="line">    <span class="string">&quot;user_id&quot;</span>: <span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个 <code>reader</code> 实例以获取从服务器收到的每个网络请求。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// To recieve data as a string we use TextDecoderStream class in pipethrough</span></span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">pipeThrough</span>(<span class="keyword">new</span> <span class="title class_">TextDecoderStream</span>()).<span class="title function_">getReader</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// To receive data as byte array we call getReader() directrly</span></span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>();</span><br></pre></td></tr></table></figure><ol start="3"><li>创建一个循环以继续接收消息，直到触发完成信号为止。在此循环内，还可以使用 SSE 消息更新前端应用程序。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;value, done&#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>();</span><br><span class="line">  <span class="keyword">if</span> (done) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received&#x27;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>完整代码示例</li></ol><p>从 POST 请求接收 SSE 消息的完整示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/sse&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/event-stream&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: &#123;</span><br><span class="line">      <span class="string">&quot;user_id&quot;</span>: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">pipeThrough</span>(<span class="keyword">new</span> <span class="title class_">TextDecoderStream</span>()).<span class="title function_">getReader</span>()</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;value, done&#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>();</span><br><span class="line">  <span class="keyword">if</span> (done) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received&#x27;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于完成设置循环的示例 <code>Express</code> 框架示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/completion&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;no-cache&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/event-stream&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Connection&#x27;</span>, <span class="string">&#x27;keep-alive&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">flushHeaders</span>() <span class="comment">// flush the headers to establish SSE with client</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> response = openai.<span class="title function_">createCompletion</span>(&#123;</span><br><span class="line">    <span class="attr">model</span>: <span class="string">&#x27;text-davinci-003&#x27;</span>,</span><br><span class="line">    <span class="attr">prompt</span>: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">    <span class="attr">max_tokens</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">temperature</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">stream</span>: <span class="literal">true</span></span><br><span class="line">  &#125;, &#123; <span class="attr">responseType</span>: <span class="string">&#x27;stream&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">  response.<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    resp.<span class="property">data</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> lines = data.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="title function_">filter</span>(<span class="function"><span class="params">line</span> =&gt;</span> line.<span class="title function_">trim</span>() !== <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> line <span class="keyword">of</span> lines) &#123;</span><br><span class="line">        <span class="keyword">const</span> message = line.<span class="title function_">replace</span>(<span class="regexp">/^data: /</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (message === <span class="string">&#x27;[DONE]&#x27;</span>) &#123;</span><br><span class="line">          res.<span class="title function_">write</span>(<span class="string">&#x27;data: DONE\n\n&#x27;</span>)</span><br><span class="line">          res.<span class="title function_">end</span>()</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> parsed = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message)</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="string">`data: <span class="subst">$&#123;parsed.choices[<span class="number">0</span>].text&#125;</span>\n\n`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;最近在写一个类似于&lt;code&gt;ChatGPT&lt;/code&gt;的流式输出的后端接口，查找资料以及控制台查看到这一类的开发都是使用的&lt;code&gt;SSE&lt;/code&gt;。后端查资料一顿开搞，前端却犯了难…前端使用&lt;code&gt;Ev</summary>
      
    
    
    
    <category term="各种技术" scheme="https://blog.xez.cc/categories/%E5%90%84%E7%A7%8D%E6%8A%80%E6%9C%AF/"/>
    
    <category term="前端开发" scheme="https://blog.xez.cc/categories/%E5%90%84%E7%A7%8D%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="SSE" scheme="https://blog.xez.cc/tags/SSE/"/>
    
    <category term="前端开发" scheme="https://blog.xez.cc/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Event-Stream" scheme="https://blog.xez.cc/tags/Event-Stream/"/>
    
  </entry>
  
  <entry>
    <title>小白都能看懂的Docker一步步构建后端程序教程</title>
    <link href="https://blog.xez.cc/posts/f255ffad.html"/>
    <id>https://blog.xez.cc/posts/f255ffad.html</id>
    <published>2023-07-17T11:56:56.000Z</published>
    <updated>2023-07-29T14:04:12.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default no-icon flat"><p>✨ 最近在完成项目时，需要先部署一份后端程序给到前端调试，比较久之前实现过Docker部署Golang后端项目<del>（太久没用忘记了）</del>，接着这个机会上网学习并回顾一下。</p></div><p>首先我们要知道两种文件：Dockerfile和docker-compose.yml，在一些开源项目中很常见。</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ul><li>详见官方安装文档：<a href="https://docs.docker.com/engine/install/">Install Docker Engine</a></li><li>或者菜鸟教程：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">Docker 安装</a> <del>（我每次安装都去菜鸟教程复制命令）</del></li></ul><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是用于构建 Docker 镜像的一种脚本语言，它包含一系列的指令和参数，用于指定如何构建镜像。在 Dockerfile 中，我们可以指定基础镜像、容器中运行的命令、需要复制到容器中的文件、环境变量等等。通过编写 Dockerfile，我们可以将应用程序打包到一个独立的、可移植的镜像中，这使得应用程序的部署和运行变得非常简单和可靠。</p><p>上面的文本通俗来说，Dockerfile 是一个用于构建 Docker 镜像的脚本语言，它包含一系列的指令和参数，用于指定如何构建镜像并完成应用程序的打包和部署。</p><p>下面是一个示例，将一个简单的Go语言程序用Docker运行起来：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取运行的镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="comment"># 构建项目，编译成可执行的二进制文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o main .</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 运行构建项目的二进制文件</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./main&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><div class="note warning flat"><p>🌟 使用之前需要安装docker-compose：<a href="https://docs.docker.com/compose/install/">Installation scenarios</a>，这里推荐在安装了Docker之后，在 Ubuntu 等类 Unix 系统上使用 <code>sudo apt install docker-compose</code> 安装，CentOS 等类 Red Hat 的系统上使用 <code>sudo yum install docker-compose</code> 安装。</p></div><p>Docker Compose 是一个 Docker 官方提供的工具，用于简化多个 Docker 容器的管理。通过 Docker Compose，我们可以使用一个 YAML 文件来定义和配置多个容器，然后使用一个命令就可以启动、停止和管理这些容器。使用 Docker Compose 可以帮助我们更方便地管理多个容器，同时也可以加快应用程序的开发和部署流程。</p><p>简言之就是可以将多个 Docker 容器组合在一起，并通过一个配置文件来定义它们之间的<strong>关系和运行方式</strong>。</p><p>下面是一个示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>这个示例使用了Docker Compose的YAML文件格式，定义了两个服务：web和db，在该示例中，web服务是一个基于Dockerfile构建的Web应用程序，该应用程序监听8080端口。db服务则是一个使用MySQL 5.7镜像启动的数据库服务。</p><p>Docker compose中可以使用服务名称来指定服务之间的连接，在这个示例中，web服务可以<strong>使用 db 作为数据库的主机名来连接 db 服务</strong>。</p><h2 id="部署后端程序"><a href="#部署后端程序" class="headerlink" title="部署后端程序"></a>部署后端程序</h2><p>一般来说，一个后端程序需要有<strong>程序主体</strong>、<strong>配置文件</strong>、<strong>关系型数据库</strong> 和 <strong>Redis数据库</strong>，这里关系型数据库<strong>用MySQL作为示例部署一个Go语言的后端程序</strong>。</p><h3 id="确定部署流程"><a href="#确定部署流程" class="headerlink" title="确定部署流程"></a>确定部署流程</h3><p>我们部署一个后端程序一般的步骤是：</p><ul><li>编写配置文件，方便使用时随时修改</li><li>有Golang环境，将程序编译成可执行二进制文件</li><li>运行程序</li><li>程序连接数据库</li><li>用户调用接口使用</li></ul><p>那么我们就可以按照上面步骤来编写Dockerfile和docker-compose.yml文件了</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>Dockerfile中常用的指令解释，还是很好理解的：</p><ul><li><code>FROM</code>: 指定基础镜像，例如 FROM golang:1.16-alpine，表示以 golang:1.16-alpine 为基础镜像构建 <strong>（这里的基础镜像来自 Docker 镜像仓库）</strong>。</li><li><code>RUN</code>: 在容器内部执行命令，例如 RUN apt-get update &amp;&amp; apt-get install -y curl，表示在容器内部执行更新和安装 curl 命令。</li><li><code>COPY</code>: 复制本地文件到容器内部，例如 COPY .&#x2F;app &#x2F;app，表示将主机当前目录下的 app 目录复制到容器内部的 &#x2F;app 目录。</li><li><code>WORKDIR</code>: 设置容器内部的工作目录，例如 WORKDIR &#x2F;app，表示将容器内部的工作目录设置为 &#x2F;app。</li><li><code>EXPOSE</code>: 暴露容器内部的端口，例如 EXPOSE 8080，表示暴露容器内部的 8080 端口。</li><li><code>CMD</code>: 设置容器启动时需要执行的命令，例如 CMD [“.&#x2F;app”]，表示容器启动时执行 &#x2F;app 命令。</li><li><code>ENTRYPOINT</code>: 用于设置容器启动时需要执行的程序。</li><li><code>ENV</code>: 用于设置环境变量。</li></ul><p>下面就是编写Dockerfile的教程：</p><ol><li><p>我们先要准备一个脚本，因为在数据库和我们自己的程序并行部署构建时，会出现数据库还没启动，我们自己的程序就开始连接，导致连接失败。这里我们需要一个脚本：<code>wait-for-it.sh</code>。</p><blockquote><p>🔮 脚本仓库：<a href="https://github.com/vishnubob/wait-for-it">https://github.com/vishnubob/wait-for-it</a>，直接下载仓库中的 <code>wait-for-it.sh</code> 即可，这里演示我们将它放在我们程序的根目录。</p></blockquote></li><li><p>我们先要拉取一个基础运行的镜像，这里就用官方镜像库中的 <code>golang:lastest</code> 来作为基础镜像（<strong>也可以指定版本</strong>），方便后续操作，我们将他别名为 <code>builder</code>。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:lastest AS builder</span><br></pre></td></tr></table></figure><p> 在这个基础镜像环境下，相当于我们的程序已经<strong>在有Go语言环境下的虚拟机</strong>下运行了。</p></li><li><p>我们要配置好该有的一些设置。在Go语言写的后端程序中，有一些包下载的时候因为众所周知网络原因 <em>（我想学习Go语言的同学都有感受）</em>，一些包没法直接拉取下来，需要借助设置 <code>GOPROXY</code> ，借助代理来下载包。同时保证我们编译的程序是 <code>Linux</code> 系统、 <code>X86</code> 架构环境运行 <em>（使用arm架构的同学自行修改）</em>，所以我们需要设置程序的环境变量。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct \</span><br><span class="line">    CGO_ENABLED=<span class="number">0</span> \</span><br><span class="line">    GOOS=linux \</span><br><span class="line">    GOARCH=amd64</span><br></pre></td></tr></table></figure></li><li><p>我们设置一个工作目录 <code>/build</code> （叫啥都行，举个例子而已），让程序在这个目录中编译和执行。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么要设置工作目录：</strong>WORKDIR 指令用于设置 Docker 容器中的工作目录。它会在容器中创建一个指定的目录，并将其作为后续指令（如 RUN, CMD, ENTRYPOINT）的默认工作目录。也就是说，当我们执行其他指令时，会在这个工作目录下进行。</p></blockquote></li><li><p>将我们的代码复制到容器中。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么COPY指令两边都是<code>.</code>：</strong>使用 COPY 指令时，第一个参数表示要复制的源文件或目录的路径，第二个参数表示目标路径。当第二个参数是一个相对路径时，它将被视为相对于 WORKDIR 指令设置的工作目录。<br> 设置工作目录后，<code>COPY . .</code> 中第一个参数 <code>.</code> 表示当前目录，也就是 Dockerfile 所在的目录，第二个参数 <code>.</code> 表示相对于工作目录 &#x2F;build 的当前目录，也就是将当前目录复制到容器的 &#x2F;build 目录中。</p></blockquote></li><li><p>我们就要开始下载程序中用到的第三方包了，这里需要执行命令 <code>go mod download</code>。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod download</span></span><br></pre></td></tr></table></figure></li><li><p>我们将程序编译成二进制可执行文件，执行命令 <code>go build -o main</code>。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o main</span></span><br></pre></td></tr></table></figure></li><li><p>为了节省运行时的性能开销，<strong>能不使用到资源的尽量不要</strong>。因为我们已经编译好了可运行的二进制文件，所以运行起来并不需要Go语言环境，这里可以选择在更小的基础镜像中运行，这里我们选择 <code>debian:bullseye-slim</code> ，只包含了<strong>最基本的系统组件</strong>和<strong>软件包</strong>，用不到的东西基本没有。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:bullseye-slim</span><br></pre></td></tr></table></figure><blockquote><p>❗ 在运行起来的时候可能会发现，当程序有对https协议的API接口等请求时会出现 <strong>“docker tls: failed to verify certificate: x509: certificate signed by unknown authority”</strong> 这表明我们运行的环境里面没有配置证书，这时我们可以通过apt包管理来安装相关包。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install apt-utils &amp;&amp; apt install -y ca-certificates</span></span><br></pre></td></tr></table></figure><p>❗ 在运行起来的时候还可能会发现，时区不太对，所以还要安装响应的包和指令来更改时区。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y tzdata &amp;&amp;\</span></span><br><span class="line"><span class="language-bash"><span class="built_in">ln</span> -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">dpkg-reconfigure -f noninteractive tzdata</span></span><br></pre></td></tr></table></figure><div class="note info modern"><p>如果有其他的需求也可自己装一些包。</p></div><p>❗ 如果是国内服务器换源会更快，可以在<strong>上面指令之前</strong>加上换源指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian bullseye main&quot;</span> &gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian-security bullseye-security main&quot;</span> &gt;&gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian bullseye-updates main&quot;</span> &gt;&gt; /etc/apt/sources.list</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>然后从原来的编译虚拟机中将编译好的<strong>可执行文件</strong>以及<strong>配置文件</strong>（示例为 <code>config.yaml</code>）复制到这个新的镜像环境中。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /build/main /</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./config.yaml /</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>下面为啥不用 --from&#x3D;builder：</strong>因为第一个是在上面镜像构建的环境中的build工作目录中编译好的文件，不加是直接从<strong>当前目录</strong>（没在容器中）复制文件。当然也可以加，从上面镜像构建的环境中获取，两个文件一样，所以没必要加。</p></blockquote></li><li><p>将我们的脚本也复制过来，并且给他775权限，可运行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./wait-for-it.sh /</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 775 wait-for-it.sh</span></span><br></pre></td></tr></table></figure></li></ol><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">如果你的后端程序用不着数据库</summary><div class="toggle-content"><p>如果那你的程序用不着数据库，那么就不存在容器之间的关联了，<strong>第1步和第10步就无需使用</strong>，因为你不需要连接数据库（滑稽）。</p><p>当然，程序运行的话则需要在Dockerfile这里写了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./main&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>完整版Dockerfile代码：</p><div class="tip info"><p>因为每个指令都会产生一个新的镜像层，不精简指令的话会产生很多镜像，所以下面代码为精简后的代码。</p></div><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为我们的镜像设置必要的环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct \</span><br><span class="line">    CGO_ENABLED=<span class="number">0</span> \</span><br><span class="line">    GOOS=linux \</span><br><span class="line">    GOARCH=amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代码复制到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载依赖项和编译成二进制可执行文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod download &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    go build -o main</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一个更小的镜像运行</span></span><br><span class="line"><span class="keyword">FROM</span> debian:bullseye-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从builder环境COPY编译的二进制文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /build/main /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY配置文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./config.yaml /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 换源 &amp; 安装证书 &amp; 调整时区 &amp; 增加执行权限</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian bullseye main&quot;</span> &gt; /etc/apt/sources.list &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian-security bullseye-security main&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian bullseye-updates main&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install apt-utils &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    apt install -y ca-certificates &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    apt-get install -y tzdata &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    dpkg-reconfigure -f noninteractive tzdata &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> +x ./mian</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./main&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p &lt;host-port&gt;:&lt;container-port&gt; &lt;image-name&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>CMD和RUN的区别：</strong>CMD 指令用于在容器启动时运行一个命令。当我们使用 docker run 命令启动容器时，Docker 会在容器内部执行 CMD 指令中指定的命令。如果在 Dockerfile 中定义了多个 CMD 指令，只有最后一个 CMD 指令会生效。RUN 指令用于在 Docker 镜像构建过程中执行命令。</p></blockquote></div></details><p>这里编写Dockerfile文件就到尾声了，下面是上面步骤的完整 <code>Dockerfile</code> 文件内容。</p><div class="tip info"><p>因为每个指令都会产生一个新的镜像层，不精简指令的话会产生很多镜像，所以下面代码为精简后的代码。</p></div><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:latest AS builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为我们的镜像设置必要的环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    GOPROXY=https://goproxy.cn,direct \</span><br><span class="line">    CGO_ENABLED=<span class="number">0</span> \</span><br><span class="line">    GOOS=linux \</span><br><span class="line">    GOARCH=amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代码复制到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载依赖项和编译成二进制可执行文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod download &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    go build -o main</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一个更小的镜像运行</span></span><br><span class="line"><span class="keyword">FROM</span> debian:bullseye-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从builder环境COPY编译的二进制文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /build/main /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY配置文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./config.yaml /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY等待脚本</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./wait-for-it.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 换源 &amp; 安装证书 &amp; 调整时区 &amp; 增加执行权限</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian bullseye main&quot;</span> &gt; /etc/apt/sources.list &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian-security bullseye-security main&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.aliyun.com/debian bullseye-updates main&quot;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install apt-utils &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    apt install -y ca-certificates &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    apt-get install -y tzdata &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    dpkg-reconfigure -f noninteractive tzdata &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> +x wait-for-it.sh &amp;&amp;\</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> +x ./main</span></span><br></pre></td></tr></table></figure><div class="note warning modern"><p>这里我们编写的Dockerfile文件是给到下面docker-compose.yml使用的，所以不需要将编译好的程序在这里使用执行指令执行。</p></div><h3 id="编写docker-compose-yml文件"><a href="#编写docker-compose-yml文件" class="headerlink" title="编写docker-compose.yml文件"></a>编写docker-compose.yml文件</h3><p>Docker compose文件使用的是.yml后缀的YAML格式配置文件，文件内主要包括：</p><ul><li><code>version</code>： 指定 Docker Compose 文件的版本。该字段值需要使用字符串格式进行指定，例如 version: ‘3’，<strong>目前最新版本使用’3’版本就好</strong>。</li><li><code>services</code>： 多个容器的服务配置都在services下：<ul><li><code>container_name</code>：字段用于指定容器的名称。每个容器都有自己的名称，<strong>方便来标识和管理容器</strong>。</li><li><code>image 或 build</code>：指定服务使用的<strong>镜像名称或 Dockerfile 路径</strong>。如果同时指定了 image 和 build，则 Compose 将使用 build 选项构建镜像，并使用 image 选项指定的名称来标记该镜像。</li><li><code>command</code>：指定容器启动时运行的命令。</li><li><code>environment</code>：指定容器运行时需要的环境变量。</li><li><code>ports</code>：指定主机端口与容器端口的映射关系。格式为 host_port:container_port。</li><li><code>depends_on</code>：指定容器间的依赖关系。这可以确保某个服务在其所依赖的服务启动之后再启动。</li><li><code>volumes</code>：用于定义容器和主机之间的数据卷（volume）映射关系。数据卷是一种持久化存储数据的方式，<strong>它可以在容器和主机之间共享数据</strong>。</li></ul></li></ul><p>认识这些后，我们就可以编写docker-compose.yml文件了，再确定一下我们需要的服务：<strong>后端程序、关系型数据库和Redis缓存数据库</strong>，所以我们需要编写<strong>3个</strong>services服务配置来支撑。</p><ol><li><p>打上版本号和services服务。</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各种服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="comment"># ...写下面的服务</span></span><br></pre></td></tr></table></figure> <div class="note info modern"><p>注意下面服务配置每行的缩进，都是在services下的，这里体现不出来。</p></div></li><li><p>配置Redis服务，这里我们使用使用<code>redis</code>作为服务名，<code>redis:latest</code>镜像作为redis数据库服务，<code>project_redis</code>作为运行时容器名称，将容器内的6379端口映射到本机运行环境上（因为默认端口为6379），以及使用<code>REDIS_PASSWORD</code>这个<strong>镜像规定的环境变量</strong>来设置Redis数据库的密码。</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis服务名</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># 使用的镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">project_redis</span></span><br><span class="line">    <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="comment"># 环境变量配置</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="comment"># Redis服务器密码</span></span><br><span class="line">        <span class="attr">REDIS_PASSWORD:</span> <span class="string">redis_password</span></span><br></pre></td></tr></table></figure><blockquote><p><code>ports</code>参数的端口映射的形式为：<strong>&lt;本机端口&gt;:&lt;容器内端口&gt;</strong></p></blockquote><blockquote><p><code>environment</code>中，还有更多的参数，这里不常用就没有列举出来，具体看：<a href="https://hub.docker.com/_/redis">https://hub.docker.com/_&#x2F;redis</a></p></blockquote></li><li><p>配置MySQL服务，这里我们使用使用 <code>mysql</code> 作为服务名，<code>mysql:latest</code> 镜像作为mysql数据库服务。</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">project_mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="comment"># 映射存储数据</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./mysql/data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="comment"># mysql中ROOT密码</span></span><br><span class="line">        <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">password</span></span><br><span class="line">        <span class="comment"># 数据库名</span></span><br><span class="line">        <span class="attr">MYSQL_DATABASE:</span> <span class="string">db</span></span><br><span class="line">        <span class="comment"># 数据库普通用户名</span></span><br><span class="line">        <span class="attr">MYSQL_USER:</span> <span class="string">user</span></span><br><span class="line">        <span class="comment"># 数据库普通用户密码</span></span><br><span class="line">        <span class="attr">MYSQL_PASSWORD:</span> <span class="string">user_password</span></span><br></pre></td></tr></table></figure><blockquote><p>我们使用 <code>volumes</code> 关键字来将容器内的数据映射到本地目录 <strong>（&lt;本地目录&gt;:&lt;容器内目录&gt;）</strong>，防止容器被删除后在容器内的数据取不出来，不会轻易丢失数据。这份数据还能作为本机运行的mysql使用。</p></blockquote><blockquote><p><code>environment</code>中，必须的有<strong>MYSQL_ROOT_PASSWORD</strong>、<strong>MYSQL_DATABASE</strong>、<strong>MYSQL_USER</strong>和<strong>MYSQL_PASSWORD</strong>作为初始化数据库的配置，更多查看：<a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_&#x2F;mysql</a></p></blockquote></li><li><p>配置自己写好的后端服务，这里和上面两个不一样的是，上面是使用的 <code>image</code> 关键字构建项目，而这里我们使用 <code>build</code> 来构建项目，<code>volumes</code> 将配置文件放在本地映射到容器内，方便我们及时修改配置文件<strong>不用重新构建项目</strong>，<code>command</code> 作为我们此服务最终执行的命令，<code>environment</code> 可以放一些环境变量供我们的程序调用。</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">api_service:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">project_api</span></span><br><span class="line"><span class="comment"># build构建自己的项目</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">    <span class="comment"># 项目路径</span></span><br><span class="line">    <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">    <span class="comment"># Dockerfile文件名</span></span><br><span class="line">    <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line"><span class="comment"># 暴露配置文件到本机</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./config.yaml:/config.yaml</span></span><br><span class="line"><span class="comment"># 执行命令等待</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">&quot;./wait-for-it.sh mysql:3306 -s -t 60 &amp;&amp; ./wait-for-it.sh redis:6379 -s -t 60 -- ./main&quot;</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">    <span class="attr">MYSQL_HOST:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">MYSQL_PORT:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">MYSQL_DATABASE:</span> <span class="string">text2solution</span></span><br><span class="line">    <span class="attr">MYSQL_USER:</span> <span class="string">user</span></span><br><span class="line">    <span class="attr">MYSQL_PASSWORD:</span> <span class="string">user_password</span></span><br><span class="line">    <span class="attr">REDIS_HOST:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">REDIS_PORT:</span> <span class="number">6379</span></span><br><span class="line"><span class="comment"># 依赖</span></span><br><span class="line"><span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><blockquote><p><code>build</code> 关键字下的 <strong>context</strong> 表示构建上下文路径，即Dockerfile所在的路径，我们的Dockerfile就在当前目录下，和docker-compose.yml文件在同一个目录下，那么就指定为当前目录；<strong>dockerfile</strong> 表示Dockerfile文件的名称。</p></blockquote><blockquote><p><code>depends_on</code> 表示我们这个服务要依赖那些服务，这里我们填写上面的<strong>mysql以及redis服务</strong>。填写依赖后，我们就可以通过使用其服务名作为主机名来连接其服务。比如连接mysql的host我们直接填写<strong>mysql</strong>就行，程序执行时会自动解析成mysql服务的主机IP地址。</p></blockquote><blockquote><p><code>command</code> 表示要执行的指令，这里我们使用上面提到的 <strong>wait-for-it.sh</strong> 脚本，这个脚本可以等待自定义秒数之内，某个服务可以连通后再执行后面的命令，这里就不过多赘述使用方法，具体看仓库中的介绍。我们这里等待60秒内Mysql服务和Redis服务后再启动我们自己编译好的程序。</p></blockquote></li></ol><p>至此，搭建后端程序的docker-compose.yml的示例已经完成，下面是完整代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各种服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="comment"># redis服务</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="comment"># 使用的镜像</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">        <span class="comment"># 容器名</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">project_redis</span></span><br><span class="line">        <span class="comment"># 端口映射</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">        <span class="comment"># 环境变量配置</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="comment"># Redis服务器密码</span></span><br><span class="line">            <span class="attr">REDIS_PASSWORD:</span> <span class="string">redis_password#</span> <span class="string">...写下面的服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># mysql服务</span></span><br><span class="line">    <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">project_mysql</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">        <span class="comment"># 映射存储数据</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./mysql/data:/var/lib/mysql</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="comment"># mysql中ROOT密码</span></span><br><span class="line">            <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">password</span></span><br><span class="line">            <span class="comment"># 数据库名</span></span><br><span class="line">            <span class="attr">MYSQL_DATABASE:</span> <span class="string">db</span></span><br><span class="line">            <span class="comment"># 数据库普通用户名</span></span><br><span class="line">            <span class="attr">MYSQL_USER:</span> <span class="string">user</span></span><br><span class="line">            <span class="comment"># 数据库普通用户密码</span></span><br><span class="line">            <span class="attr">MYSQL_PASSWORD:</span> <span class="string">user_password</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 自己的后端程序服务</span></span><br><span class="line">    <span class="attr">api_service:</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">project_api</span></span><br><span class="line">        <span class="comment"># build构建自己的项目</span></span><br><span class="line">        <span class="attr">build:</span></span><br><span class="line">            <span class="comment"># 项目路径</span></span><br><span class="line">            <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">            <span class="comment"># Dockerfile文件名</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">        <span class="comment"># 暴露配置文件到本机</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./config.yaml:/config.yaml</span></span><br><span class="line">        <span class="comment"># 执行命令等待</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">&quot;./wait-for-it.sh mysql:3306 -s -t 60 &amp;&amp; ./wait-for-it.sh redis:6379 -s -t 60 -- ./main&quot;</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">MYSQL_HOST:</span> <span class="string">mysql</span></span><br><span class="line">            <span class="attr">MYSQL_PORT:</span> <span class="number">3306</span></span><br><span class="line">            <span class="attr">MYSQL_DATABASE:</span> <span class="string">db</span></span><br><span class="line">            <span class="attr">MYSQL_USER:</span> <span class="string">user</span></span><br><span class="line">            <span class="attr">MYSQL_PASSWORD:</span> <span class="string">user_password</span></span><br><span class="line">            <span class="attr">REDIS_HOST:</span> <span class="string">redis</span></span><br><span class="line">            <span class="attr">REDIS_PORT:</span> <span class="number">6379</span></span><br><span class="line">        <span class="comment"># 依赖</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><div class="note info modern"><p>上面只是一个示例程序的部署编写过程，如果需要更复杂的功能请自行添加。</p></div><h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><p>我们这里需要用到<code>docker-compose</code>指令，首先<strong>打开我们的项目根目录</strong>，将Dockerfile文件和docker-compose.yml文件放在项目根目录中，输入指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up</span><br></pre></td></tr></table></figure><p>可以看到服务就在按照我们编写的docker-compose.yml中的服务按照顺序进行构建，在对于本地没有下载的镜像也会进行下载。</p><p><img src="/img/f255ffad/2023-07-20-13-20-36.png"></p><p>如果mysql以及redis服务已经完成之后，接下来会进入到我们自己程序的构建中。可以看到如图是在按照我们写的Dockerfile一步一步在完成构建。</p><p><img src="/img/f255ffad/2023-07-20-14-25-31.png"></p><p>在全部服务构建完成后，就会开始运行我们的服务。</p><div class="note info modern"><p>这里注意，运行的时候<strong>不会按照</strong>我们编写服务的顺序来执行，可以看到图中框住的部分，我们自己的后端服务是写在mysql服务后的，可是还没等mysql服务完成，我们自己的后端服务就已经开始执行等待命令了。</p></div><p><img src="/img/f255ffad/2023-07-20-14-30-02.png"></p><p>最后我们的程序已经成功运行起来。</p><p><img src="/img/f255ffad/2023-07-20-14-41-57.png"></p><h3 id="常用的docker-compose命令"><a href="#常用的docker-compose命令" class="headerlink" title="常用的docker-compose命令"></a>常用的docker-compose命令</h3><ol><li><p>上面的运行过程之后，需要保证shell界面不关闭，否则程序将会终止，所以我们需要他在后台运行。</p><p> 在启动时，加一个参数 <code>-d</code> 就能让他在后台运行：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><p>如果想要看到后台运行服务的日志，则 <code>logs</code> 命令就能看到其日志：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose logs</span><br></pre></td></tr></table></figure></li><li><p>若要关闭服务，则 <code>down</code> 命令就能关闭：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose down</span><br></pre></td></tr></table></figure></li><li><p>当修改过程序或者Dockerfile，则启动时需要重新构建，加上参数 <code>--build</code> 就能重新构建：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up --build</span><br></pre></td></tr></table></figure><blockquote><p>这里可以和第一个命令联动，后面再加 <code>-d</code> 可以让程序重新构建后在后台运行。</p></blockquote></li></ol><p>以上就是所有要讲的教程啦，<strong>希望能对你有所帮助！</strong>如果有错误或者有疑问，欢迎在评论区指出~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note default no-icon flat&quot;&gt;&lt;p&gt;✨ 最近在完成项目时，需要先部署一份后端程序给到前端调试，比较久之前实现过Docker部署Golang后端项目&lt;del&gt;（太久没用忘记了）&lt;/del&gt;，接着这个机会上网学习并回顾一下。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="各种技术" scheme="https://blog.xez.cc/categories/%E5%90%84%E7%A7%8D%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Dcoker" scheme="https://blog.xez.cc/tags/Dcoker/"/>
    
    <category term="后端" scheme="https://blog.xez.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Dockerfile" scheme="https://blog.xez.cc/tags/Dockerfile/"/>
    
    <category term="Docker-compose" scheme="https://blog.xez.cc/tags/Docker-compose/"/>
    
    <category term="搭建程序" scheme="https://blog.xez.cc/tags/%E6%90%AD%E5%BB%BA%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>参加2023年华为云开发者大会经历</title>
    <link href="https://blog.xez.cc/posts/ac15ebe0.html"/>
    <id>https://blog.xez.cc/posts/ac15ebe0.html</id>
    <published>2023-07-12T14:13:00.000Z</published>
    <updated>2023-07-15T12:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🌟 肥肠荣幸能够参加今年的华为云开发者活动，跟着我的文章来看看我参与了有哪些活动以及感想叭~ （<strong>多图警告</strong>❗）</p></blockquote><h2 id="AI重塑千行百业"><a href="#AI重塑千行百业" class="headerlink" title="AI重塑千行百业"></a>AI重塑千行百业</h2><p>因为活动举办地点比较近的缘故，所以活动第一天，直接前往 <mark class="hl-label default">东莞篮球中心</mark>  与其他外校的小伙伴们回合。不过活动方有直接从深圳北站到活动会场的大巴，不得不说在深圳的我四舍五入省了一大笔交通费呀🤤（就是稍微有点费时…）</p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="2">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-14-13-36-08.png","alt":"门口"},{"url":"/img/ac15ebe0/2023-07-14-13-48-14.png","alt":"票票，但不知道为啥是大麦的，咱也不是演唱会呀"}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><p>进入会场以后，铺面而来的就是演唱会既视感，会场中心并不是篮球场，而是精心布置的舞台。这次主题演讲主要讲解了关于 <mark class="hl-label red">盘古大模型</mark>  的介绍，前几天还看到盘古大模型在Nature上刊登！</p><p><img src="/img/ac15ebe0/2023-07-14-14-31-34.png"></p><p>首先即是介绍盘古大模型在不同行业的成果：</p><ul><li><strong>在矿山行业</strong>，能够让地面上工作的人员不用下井，就能看得全、看得清、看得准，可以在地面上来进行煤矿煤机的一个操控的作业。</li><li><strong>在铁路行业</strong>，平均1000辆的枢纽站在平常要采集400万张图片给检测员检测，在盘古大模型的帮助下检测员需要看的图片锐减到20万，大大的降低了检测员的工作量，还提高了工作效率。并且现在可以对铁路上的67种货车进行检测，检测430多种故障，故障的检测漏检率为0，筛除率高达95%。</li><li><strong>在气象行业</strong>，盘古提前10天精准的预测到了马娃台风的路径，预测的速度和预测的精度已经大大的优于传统的方法。欧洲气象局已经将盘古气象输出的结果作为欧洲气象局比较他们的系统的参考之一，并且国际期刊Nature正式刊登了盘古气象的相关文章。</li><li><strong>在金融行业</strong>，在初期的试点阶段，帮助网点的柜员轻松的工作、处理各种业务，现在盘古大模型能够根据客户的问题，为柜台工作人员自动的生成流程和操作指导，将原来平均5次的操作已经缩减为1次，帮助柜员他的办结时间提升了5分钟之上。盘古就是要在金融行业里头帮助网点柜员，都能拥有自己的工作助助手、智慧助手。</li><li><strong>在制造业</strong>，没有大模型之前，华为公司的单产线上面的器件分配计划，往往需要花3小时才能做起这一天这条产线的一个器件分配计划。现在通过大模型只需要一分钟，就可以做出未来三天的这个业务计划。盘古应用于产线也产生了极高的效率。</li><li><strong>在程序开发领域</strong>，内嵌了盘古大模型的Code Snap，现在就可以成为程序员的助理。他们的使命，就是一句话要生成代码，一个案件生成测试用例，一次点击生成解释注释，一条指令要能完成部署。（<strong>希望未来能够比Copilot好用还能够用得起😳</strong>）</li><li><strong>在数字内容生产</strong>，以前3个人花了3天的时间，生成了一个3分钟的视频。现在只需要送20秒的历史视频，3分钟就可以完成这3分钟的视频，实现时长1:1渲染。让盘古数字人的这样的一个功能能够在企业的客服、在线教育，在电商文娱直播等很多的行业里头使用，通过盘古大模型，也能为每个企业的员工、行业的员工都能够有一个数字人帮助员工实现数字人自由。</li></ul><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="100" data-limit="4">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-14-14-08-45.png","alt":""},{"url":"/img/ac15ebe0/2023-07-14-14-15-21.png","alt":""},{"url":"/img/ac15ebe0/2023-07-14-14-28-18.png","alt":""},{"url":"/img/ac15ebe0/2023-07-14-14-29-15.png","alt":""},{"url":"/img/ac15ebe0/2023-07-14-14-29-30.png","alt":""},{"url":"/img/ac15ebe0/2023-07-14-14-34-31.png","alt":""},{"url":"/img/ac15ebe0/2023-07-14-14-37-23.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><p>上面的重头戏讲完之后，接下来就是讲解盘古大模型的 <mark class="hl-label default">炼成</mark>  和 <mark class="hl-label default">创新</mark>  。同时还在现场实时的使用盘古大模型为 <mark class="hl-label default">其他服务商</mark>  开发的应用，以及华为云自己开发的 <mark class="hl-label default">MetaStudio数字人</mark>  和 <mark class="hl-label default">CodeSnap</mark>  等的演示。</p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="150" data-limit="4">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-11-10-56.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-11-55.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-13-35.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><h2 id="松山湖华为溪村"><a href="#松山湖华为溪村" class="headerlink" title="松山湖华为溪村"></a>松山湖华为溪村</h2><blockquote><p>🖼️ 下方图源部分来自活动官方，部分来自同行小伙伴（其中一位小伙伴博客：<a href="https://www.xuemian168.com/">www.xuemian168.com</a>），部分来自自己拍摄~（照片太多，就不放原图辽~ <del>流量费耗不起，悲</del>）</p></blockquote><h3 id="Day-One"><a href="#Day-One" class="headerlink" title="Day One"></a>Day One</h3><p>在华为溪村好好学习<del>（开心游玩）</del>才是参加这次活动最期待的地方！进入溪村门口，到处都是本次活动的元素，非常契合活动！</p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="2">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-11-36-19.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-31-57.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-49-58.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><p>第一天和小伙伴们一起领取瑞雪姐定制的HCSD的衣服和帽子，不得不说样式还是很好康的（吹爆瑞雪姐）！这一天参观了和体验了溪村F区和H区的盘古模型及其千行百业的技术展示，以及听取到一些大牛的演讲。同时还做到了小火车！活动方的礼品也超级多，一天下来感觉像在进货（bushi），同时CodeSnap的云宝也非常可爱(●’◡’●)！内容太多不一一介绍辽！</p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="3">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-11-38-06.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-38-39.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-39-32.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-39-52.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-40-14.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-41-06.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-41-21.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-42-09.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-11-49-29.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><p>本以为晚上的嘉年华活动没有晚餐提供，结果超多小吃，当然排队等候的人也居多，不过可以吃完再来拿（就是排太久啦！）。小吃街非常丰富，有串串、水果捞、饼子、刨冰（<em>不多不少排到了最后半份</em>）和饮料等（好多太多人排队没吃到的www😭），最后调饮料的小哥还炫起来了”烟花”，可惜当时在排队没靠近康…</p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="3">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-12-04-36.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-12-04-58.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-12-05-10.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-12-05-19.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-12-05-31.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-12-10-48.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><p>除了美食一条街，还有演唱会。当天在深圳有五月天的演唱会，虽然不在深圳，但是现场的乐队也唱了好多五月天的歌曲，还有Jay.Zhou周杰伦的歌曲。但是毕竟不是原唱，稍微有点差距啦，但是氛围是超级好！<em>（后面还有直接冲向舞台排排走开小火车的，社恐没敢去😱）</em></p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="2">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-15-08-11.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-15-08-29.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><p>夜深了，回酒店辽~</p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="2">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-15-12-19.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-15-12-33.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><h3 id="Day-Two"><a href="#Day-Two" class="headerlink" title="Day Two"></a>Day Two</h3><p>一大早，Codelabs要等到9:30才开始，先到周围逛了逛。逛回来被通知说 <mark class="hl-label default">极客挑战赛</mark>  还有位置，那咱就迫不及待过去了。</p><p>我做的挑战赛是华为开天aPaaS平台赛道，最最重要的点是<strong>看现场提供的教程</strong>。难度的话倒不是很难，<strong>第一个</strong>任务是建造一个将人物图片高清修复和动漫化的任务（<em>我直接百度找了张彭于晏的图片来做的第一个任务hhh）</em> ，用开天aPaaS平台建造有可视化配置变量，新增“逻辑处理块”，可视化拖拽逻辑块顺序 <em>（通俗易懂的语言来形容）</em> ，最后将处理的图片发送到邮箱里头；<strong>第二个</strong>任务是使用开天aPaaS平台和现有的数据打造一个数据可视化网页，开天aPaaS平台提供很多数据可视化的各种折线图、饼图等等，然后也有预置的排版布局，直接导入数据、选择各种数据展示样式和选择排版布局并以合适的排版来将数据可视化，更方便管理者进行数据的分析以及管理。</p><p>最后的分数是按照完成的速度以及美观度综合评分。浅拿了个奖，奖品是一个电动牙刷 <em>（从小到大还没用过这玩意，正好体验用用🐵）</em></p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="2">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-15-34-58.png","alt":"猜猜我在哪"},{"url":"/img/ac15ebe0/2023-07-15-15-35-39.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-15-38-22.png","alt":"好像没真人那么帅了2333"}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><p>但是不得不说，这个平台对于不是很懂编程的人来说，的确非常方便！<em>（计科学生头秃中）</em></p><p>接下来就是去Codelabs逛逛了（忘了拍照），体验了一下华为云的CodeSnap，CodeSnap和Github的Copilot有点相似，但不同之处是在发布会演示的时候能帮你提交commit还有能帮你部署，这两点好评！</p><p>在现场的电脑上申请CodeSnap能直接通过，上面两点没有测试（大意了…），倒是皮了让它去做OJ题目，直接选了到困难题，第一次直接给了个“if else流”，应该是太难的题目还是不能解决。旁边的工作人员小哥说Leetcode的中等题目有些可以，试了一下确实能AC。希望CodeSnap未来能有更多的提升，能做出更难得OJ题，<del>帮我解决算法题</del></p><p>（忘了拍照，放几张Codelabs现场的图片吧）</p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="2">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-15-58-27.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-15-58-43.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-15-59-00.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div><p>然后后面就是各种演讲讲座，也非常有幸我们学校老师能来这种大活动来进行演讲！</p><p>下午最后一场也参加了一场 <mark class="hl-label default">极客挑战赛</mark>  ，利用华为云图像识别API调用来识别车牌号，代码有示例代码，用Java编写。没快速查到Java将图片变成base64的代码，第三个完成，当时太晚了没奖品了www。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次溪村之旅还是挺值得的，现场看到盘古大模型的发布会，还结识了许多外校的朋友，同时也实地体验到盘古大模型的部分运用场景。领略到了当前AI发展的迅猛，在各行各业中都有许许多多高效的工具。未来AI能帮我们做的东西会不会突破现在人类的想象的极限，做到一些现在都想象不到的运用呢🤔</p><p>当然还有礼品和整个活动参与欢乐的收获，但是还有一些遗憾，听说和聊天聊技术的扫地僧大牛们都很和蔼，也很愿意分享东西，在参加别的活动的时候没有去和大牛们接触，有机会下次一定！</p><div class="gallery">  <div class="fj-gallery page_img_lazyload  data" data-rowHeight="220" data-limit="2">    <span class="gallery-data">[{"url":"/img/ac15ebe0/2023-07-15-16-15-25.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-16-18-18.png","alt":""},{"url":"/img/ac15ebe0/2023-07-15-16-18-33.png","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🌟 肥肠荣幸能够参加今年的华为云开发者活动，跟着我的文章来看看我参与了有哪些活动以及感想叭~ （&lt;strong&gt;多图警告&lt;/strong&gt;❗）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;AI重塑千行百业&quot;&gt;&lt;a href=&quot;#AI重塑千</summary>
      
    
    
    
    <category term="大学生活" scheme="https://blog.xez.cc/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="活动" scheme="https://blog.xez.cc/tags/%E6%B4%BB%E5%8A%A8/"/>
    
    <category term="华为云" scheme="https://blog.xez.cc/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    
    <category term="溪村" scheme="https://blog.xez.cc/tags/%E6%BA%AA%E6%9D%91/"/>
    
    <category term="华为云开发者大会" scheme="https://blog.xez.cc/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A/"/>
    
  </entry>
  
</feed>
